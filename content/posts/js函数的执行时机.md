---
title: "Js函数的执行时机"
date: 2019-10-11T22:40:04+08:00
draft: false
---

# js函数

## 函数分类

1. 具名函数

```js
function fn(x,y){
	return x+y
}
```

2. 匿名函数

```
let a=function(x,y){
	return x+y
}
```

3. 箭头函数

```
let f1=x=>x*x			//一句可以省略花括号
let f2=(x,y)=>{
	console.log(x)
	return x+y
}						//两个参数必须用括号括起来，两行语句要用花括号括起来，两行语句以上return是不能省略的
```

4. 构造函数

```
let f =new Function('x','y','return x+y')			//Function就是构造函数
```
* 所有函数都是Function构造出来的
* 包括Object、Array、Function

## 调用时机

<mark>函数必须调用才会执行<mark>

调用时机很重要，时机不同，结果不同

## 例子1
```js
let i=0;
for(i=0;i<6;i++){
    setTimeout(()=>{
        console.log(i)
        },0)
}
```

__这段代码执行的结果是6个6__
![6个6](/images/6个6.PNG)

### 为什么是6个6呢？

我们分析一下，按照我们的逻辑来看应该是0，1，2，3，4，5啊

原因：setTimeout是定时器，意思时设定一个时间再执行，这里定时器的时间是0ms，但是 实际是定时器还是有时间的，这段代码表达的意思是，做完手头的事情以后再<mark>马上</mark>执行定时器，所以当for循环完成之后，马上执行定时器里面的内容，所以是当i循环到6之后再执行定时器，所以就在控制台上打出来了6个6

## 例子2

```js
for(let i=0;i<6;i++){
    setTimeout(()=>{
        console.log(i)
    },0)
}
```

__这段代码的结果是0，1，2，3，4，5__

![](/images/例子2.PNG)

### 在我们看来这两段代码是一样的啊，为什么结果不一样呢？

原因：在上一个例子中i是全局变量。所以i只有一个所以它会一直被加到6才会执行，而在第二个例子中let i让每次循环都创建了一个i所以就有6个i这样当计时器执行的时候，i就等于0，1，2，3，4，5

通过这两个例子我们可以看出时机的重要，函数也是如此，调用的时机不同，其意义也不同

*我们再举几个例子：*

### 例子3：

```JS
let a=1
function fn(){
    console.log(a)
}
a=2
fn()
```
结果是2，因为先有a=2,才执行fn()

### 例子4
```js
function f1(){
	let a=1
	function f2(){
		let a=2
		console.log(a)
	}
	console.log(a)
	a=3
	f2()
}
```

这段代码的结果是1，2
![](/images/例子4.PNG)

如图调用f1，首先执行f1的作用域，所以先打出1，然后执行f1里面f2的作用域，打出2

## 作用域 

调用函数的时候不仅要看时机，还要看函数的作用域，函数执行先看自己的作用域，如果自己的作用域没有就会在离自己最近的作用域中寻找。

### 作用域的就近原则

如果多个作用域里面有同名变量a：

* 那么查找a的声明是，就想上去最近的作用域。

## 闭包

如果一个函数用到了外部的变量那么这个函数加这个变量就叫<mark>闭包</mark>

```js
function f1(){
	let a=1
	function f2(){
	console.log(a)
	}
}
```

![](/images/闭包.PNG)
如上图所示a和f2组成了闭包